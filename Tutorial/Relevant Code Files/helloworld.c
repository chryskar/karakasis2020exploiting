/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */
#include "xuartps_hw.h"
#include <stdio.h>
#include "platform.h"
#include "xscutimer.h"
#include "xparameters.h"
#include "xscugic.h"
#include "xbasic_types.h"
#include "xil_io.h"
#include <math.h>
#include "xtime_l.h"
#include <sleep.h>
#include <unistd.h>
#include <stdlib.h>
#include "xsdps.h"		/* SD device driver */
#include "xil_printf.h"
#include "ff.h"
#include "xil_cache.h"
#include "xplatform_info.h"

#define INTERRUPT_COUNT_TIMEOUT_VALUE 20000
#define _GNU_SOURCE
#define MY_PWM 0x43C00000

#define PI 3.14159265

float Kp,Kd,desired_velocity=0;
int saturation_limit=5000;
int encoder_resolution=pow(2,18),duty_resolution=(pow(2,14)-1);
int array_print[1000000][18];
int i=0,flag=0;

//Pointer to the Memory Address of the first slave register
Xuint32 *baseaddr_p = (Xuint32 *)XPAR_LAELAPS_FOUR_LEGS_DUPLICATE_IP_0_S00_AXI_BASEADDR;
//*(baseaddr_p+1) refers to the second slave register and so on

// Function prototypes
static void my_timer_interrupt_handler(void *CallBackRef);
int inv_kin(float in_t,float xc,float yc,float a,float b,float traj_freq,int phase,int param, float thdes[2]);
int pd_control(float t,int num_of_motor,float counts,float velocity,float des_angle);
int position_controller(float t,float des_angle1,float des_angle2,int leg);
float lerp(float init_value, float init_time, float fin_value, float time_interval, float time_now);
int FfsSdPolledExample(void);
int8_t inbyte_nb (void);


static FIL fil;		/* File object */
static FATFS fatfs;

/*
 * To test logical drive 0, FileName should be "0:/<File name>" or
 * "<file_name>". For logical drive 1, FileName should be "1:/<file_name>"
 */

//the name of the .txt file, where the recorded data will be stored
static char FileName[32] = "0:/reoutput.txt";

static char *SD_File;

#ifdef __ICCARM__
#pragma data_alignment = 32
u8 DestinationAddress[10*1024];
u8 SourceAddress[10*1024];
#pragma data_alignment = 4
#else
u8 DestinationAddress[10*1024*1024] __attribute__ ((aligned(32)));
u8 SourceAddress[10*1024*1024] __attribute__ ((aligned(32)));
#endif

#define TEST 7
// Global variables
int InterruptCounter = 0;

int main()
{
	init_platform();

	// Declare variables that we'll use later
	int Status;
	char Input;
	// Declare two structs.  One for the Timer instance, and
	// the other for the timer's config information
	XScuTimer my_Timer;
	XScuTimer_Config *Timer_Config;

	// Declare two structs.  One for the General Interrupt
	// Controller (GIC) instance, and the other for config information
	XScuGic my_Gic;
	XScuGic_Config *Gic_Config;

	// Look up the config information for the GIC
	Gic_Config = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);

	// Initialise the GIC using the config information
	Status = XScuGic_CfgInitialize(&my_Gic, Gic_Config, Gic_Config->CpuBaseAddress);

	// Look up the the config information for the timer
	Timer_Config = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);

	// Initialise the timer using the config information
	Status = XScuTimer_CfgInitialize(&my_Timer, Timer_Config, Timer_Config->BaseAddr);

	// Initialize Exception handling on the ARM processor
	Xil_ExceptionInit();

	// Connect the supplied Xilinx general interrupt handler
	// to the interrupt handling logic in the processor.
	// All interrupts go through the interrupt controller, so the
	// ARM processor has to first "ask" the interrupt controller
	// which peripheral generated the interrupt.  The handler that
	// does this is supplied by Xilinx and is called "XScuGic_InterruptHandler"
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, &my_Gic);

	// Assign (connect) our interrupt handler for our Timer
	Status = XScuGic_Connect(&my_Gic, XPAR_SCUTIMER_INTR, (Xil_ExceptionHandler)my_timer_interrupt_handler, (void *)&my_Timer);

	// Enable the interrupt *input* on the GIC for the timer's interrupt
	XScuGic_Enable(&my_Gic, XPAR_SCUTIMER_INTR);

	// Enable the interrupt *output* in the timer.
	XScuTimer_EnableInterrupt(&my_Timer);

	while(1)
	{

		// Enable interrupts in the ARM Processor.
		Xil_ExceptionEnable();


		// Load the timer with a value that represents one second of real time
		// HINT: The SCU Timer is clocked at half the frequency of the CPU.
		XScuTimer_LoadTimer(&my_Timer, XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ*pow(10,-3) / 2);
		//XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2 -> 1Hz
		//XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ*pow(10,-3) / 2 -> 1kHz

		// Enable Auto reload mode on the timer.  When it expires, it re-loads
		// the original value automatically.  This means that the timing interval
		// is never skewed by the time taken for the interrupt handler to run
		XScuTimer_EnableAutoReload(&my_Timer);

		// Start the SCU timer running (it counts down)
		XScuTimer_Start(&my_Timer);

		//Welcome message to the user.
		xil_printf("Start of the experiment! Provide state machine code: \n\r");

		while(flag==0){
			Input = inbyte_nb();	//non blocking function to read from terminal
			//read the state machine from terminal
			if (Input == '1'){
				flag=1;
				InterruptCounter=0;	//reset of the interrupt counter
				i=0;				//counter relevant with the storage of the experiment data
				xil_printf("State machine code is : %c. Initialization of Trotting.\n\r",Input);
			}
		}

		// There's nothing in here, the processor will just sit doing nothing.
		// The only way we'll see messages on the UART is if there's an interrupt.
		// In a real application, this is where the rest of our code would be.

		flag=1;
		while(flag==1){
			Input = inbyte_nb();
			//read the state machine from terminal
			if (Input == '0'){
				xil_printf("Experiment was terminated by user.\n\r");
				flag=2;
			}
		}

		if (flag==2)	//Termination by user. No printing
		{
			Kp=0;
			Kd=0;
			usleep(500); //waiting for 0.5 sec for another interrupt to occur that will set all PWM signals to zero.
			break;
		}

		if (flag==3)	//Termination by duration. Start printing stored data
		{
			xil_printf("Termination of the experiment! Initialization of data storage in SD Card.\n\r");
			// Disable interrupts in the Processor.
			Xil_ExceptionDisable();

			Status = store_data_in_sd();	//function responsible for the storage of the reconrded measurements to the SD card
			if (Status != XST_SUCCESS) {
				xil_printf("File System Example Test failed \r\n");
				return XST_FAILURE;
			}

			xil_printf("Termination of the data storage in SD Card. Exiting!\n\r");
			break;
		}

	}

	// Print a message to the UART to show that we've made it out of the while loop
//	printf("If we see this message, then we've broken out of the while loop\n\r");


	// Disable interrupts in the Processor.
	Xil_ExceptionDisable();

	// Disconnect the interrupt for the Timer.
	XScuGic_Disconnect(&my_Gic, XPAR_SCUTIMER_INTR);

	cleanup_platform();

	return 0;
}


static void my_timer_interrupt_handler(void *CallBackRef)
{
	// The Xilinx drivers automatically pass an instance of
	// the peripheral which generated in the interrupt into this
	// function, using the special parameter called "CallBackRef".
	// We will locally declare an instance of the timer, and assign
	// it to CallBackRef.  You'll see why in a minute.
	XScuTimer *my_Timer_LOCAL = (XScuTimer *) CallBackRef;
    float thdes_1[2],thdes_2[2], thdes_3[2],thdes_4[2];
    float a,b,xc,yc,t;
    float traj_freq;
    int phase,param,leg;
    float a_init,a_final,b_init,b_final,kp_init,kp_final,kd_init,kd_final;
    float lerp_t_interval, experiment_duration;

    a_final=0.03;				//final value of the semi-major axis's length of the ellipse (m)
    b_final=0.03;				//final value of the semi-minor axis's length of the ellipse (m)
    kp_final=500;				//final value of the Kp Control Gain
    kd_final=300;				//final value of the Kd Control Gain
    lerp_t_interval=5.0;		//Duration of the linear interpolation of the ellipse parameters (sec)
    experiment_duration=20.0;	//Duration of the trotting experiment (sec)

    a_init=0.0;					//initial value of the semi-major axis's length of the ellipse (m)
    b_init=0.0;					//initial value of the semi-minor axis's length of the ellipse (m)
    kp_init=0;					//initial value of the Kp Control Gain
    kd_init=0;					//initial value of the Kd Control Gain

    xc= 0.0;					//x coordinate of the ellipse's center (m)
    yc= 0.570;					//y coordinate of the ellipse's center (m)
    phase=0;					//initial phase of the elliptical motion (degrees)
    param=0;					//flattening parameter of the y axis amplitude ( b )
    traj_freq=1.0;				//frequency of elliptical motion (Hz)

	// Here we'll check to see if the timer counter has expired.
	// Technically speaking, this check is not necessary.
	// We know that the timer has expired because that's the
	// reason we're in this handler in the first place!
	// However, this is an example of how a callback reference
	// can be used as a pointer to the instance of the timer
	// that expired.  If we had two timers then we could use the same
	// handler for both, and the "CallBackRef" would always tell us
	// which timer had generated the interrupt.
	if (XScuTimer_IsExpired(my_Timer_LOCAL))
	{
		// Clear the interrupt flag in the timer, so we don't service
		// the same interrupt twice.
		XScuTimer_ClearInterruptStatus(my_Timer_LOCAL);

		// Increment a counter so that we know how many interrupts
		// have been generated.  The counter is a global variable
		InterruptCounter++;
		t=(InterruptCounter*pow(10,-3));	//this variable represents time

		if (flag==0 && t<lerp_t_interval){//control to zero point
			a=a_init;
			b=b_init;
			Kp=round(lerp(kp_init,0.0,kp_final,lerp_t_interval,t));
			Kd=round(lerp(kd_init,0.0,kd_final,lerp_t_interval,t));
		}

		if (flag==1 && t<lerp_t_interval){//linear interpolation to the desired values of ellipse parameters
			a=lerp(a_init,0.0,a_final,lerp_t_interval,t);
			b=lerp(b_init,0.0,b_final,lerp_t_interval,t);
		}

		if (flag==1 && t >= experiment_duration-lerp_t_interval){//linear interpolation to the desired values of ellipse parameters
			a=lerp(a_final,0.0+experiment_duration-lerp_t_interval,a_init,lerp_t_interval,t);
			b=lerp(b_final,0.0+experiment_duration-lerp_t_interval,b_init,lerp_t_interval,t);
		}

		if (flag==2){
			Kp=0;	//Disable PWM Outputs to zero.
			Kd=0;
		}

		if (flag==3){
			xil_printf("We should not see this message printed in the terminal.\n\r");
		}

		if (t >= experiment_duration && flag == 1){			//Duration of the experiment has reached its end
			flag=3;
			Kp=0;
			Kd=0;
		}

		phase=0;
		inv_kin(t,xc,yc,a,b,traj_freq,phase,param,thdes_1); 	//calculation of the desired angles for leg 1
		thdes_1[0]=-thdes_1[0];									//Due to the fact that this is a right leg, the signs have to be inverted
		thdes_1[1]=-thdes_1[1];
		phase=0;
		inv_kin(t,xc,yc,a,b,traj_freq,phase,param,thdes_2); 	//calculation of the desired angles for leg 2
		phase=0;
		inv_kin(t,xc,yc,a,b,traj_freq,phase,param,thdes_3); 	//calculation of the desired angles for leg 3
		thdes_3[0]=-thdes_3[0];									//Due to the fact that this is a right leg, the signs have to be inverted
		thdes_3[1]=-thdes_3[1];
		phase=0;
		inv_kin(t,xc,yc,a,b,traj_freq,phase,param,thdes_4); 	//calculation of the desired angles for leg 4

	//	   thdes[0]=+20;
	//	   thdes[1]=-20;										//bypass inverse kinematics

		leg=1;												//unique id which distinguishes the legs. Leg=1->FL leg of Laelaps II
		position_controller(t,thdes_1[0],thdes_1[1],leg); 	//implementation of the PD Control

		leg=2;												//unique id which distinguishes the legs. Leg=2->FR leg of Laelaps II
		position_controller(t,thdes_2[0],thdes_2[1],leg); 	//implementation of the PD Control

		leg=3;												//unique id which distinguishes the legs. Leg=3->HL leg of Laelaps II
		position_controller(t,thdes_3[0],thdes_3[1],leg); 	//implementation of the PD Control

		leg=4;												//unique id which distinguishes the legs. Leg=4->HR leg of Laelaps II
		position_controller(t,thdes_4[0],thdes_4[1],leg); 	//implementation of the PD Control

	}
}

int inv_kin(float in_t,float xc,float yc,float a,float b,float traj_freq,int phase,int param, float thdes[2]){
	float lv1, lv2;
	float xtr_new, ytr_new, ctheta2_new, stheta2_new_plus, thetainv1;
	float thetainv2;
	float lv1_2,lv2_2,traj_vel,angle,b_ellipse_filtered;
	float temp1,temp2;
	int knee_configuration;

	lv1 = 0.250;				//length of each leg's first link (m)
	lv2 = 0.350;				//length of each leg's second link (m)
	knee_configuration = -1;	//Knee Configuration (-1: forward, +1: backward)
	traj_vel = traj_freq*2*PI;

	lv1_2=lv1*lv1;
	lv2_2=lv2*lv2;
	angle=traj_vel*in_t + phase*PI/180;

	if (fmodf(angle,2*PI)<PI)
        b_ellipse_filtered = param * b;
    else{
        b_ellipse_filtered = b;
    }

	sincosf(angle,&temp2,&temp1);

	xtr_new = xc + (a * temp1);
	ytr_new = yc + b_ellipse_filtered * temp2;
//	xtr_new = 0;
//	ytr_new = 0.570;
	ctheta2_new = (pow(xtr_new,2)+pow(ytr_new,2)-lv1_2-lv2_2)/(2*lv1*lv2);
	stheta2_new_plus = knee_configuration*sqrt(1 - pow(ctheta2_new,2));
	thetainv2 = -atan2(ytr_new, xtr_new)
			+ atan2((lv1 * stheta2_new_plus), (lv2 + lv1 * ctheta2_new))
			+ PI / 2;
	thetainv1 = thetainv2 - atan2(stheta2_new_plus, ctheta2_new);

	thdes[0]=thetainv1*180/PI;
	thdes[1]=thetainv2*180/PI;
	return 1;
}

int pd_control(float t,int num_of_motor,float counts,float velocity,float des_angle){

	float position,desired_angle=des_angle;
	int whole_pos,thousandths_pos,whole_vel,thousandths_vel,Pout,Pout_v,dir,duty;
	int whole_des,thousandths_des,whole_t,thousandths_t;
	char sign_des,sign_pos,sign_vel;
	whole_t=t;						//iteration's integer part
	thousandths_t=(t-whole_t)*1000;	//iteration's decimal part

	whole_des=fabsf(desired_angle);						//desired angle's integer part
	thousandths_des=(fabsf(desired_angle)-whole_des)*1000;	//desired angle's decimal part

	if (desired_angle>0)
		sign_des = '+';
	else
		sign_des = '-';

	if ((num_of_motor == 1) || (num_of_motor == 3) || (num_of_motor == 5) || (num_of_motor == 7)){ //gear ratio=1029/13=> max_counts=2000*1029/13=158307
		if (counts <= 79153)
			position = counts*180/79153;			//positive angle
		else if (counts > 79153)
			position = (counts-158307)*180/79153;	//negative angle
	}
	else if ((num_of_motor == 2) || (num_of_motor == 4) || (num_of_motor == 6) || (num_of_motor == 8)){ //gear ratio=98=> max_counts=2000*98=196000
		if (counts <= 98000)
			position=counts*180/98000;				//positive angle
		else if (counts > 98000)
			position=(counts-196000)*180/98000;		//negative angle
			//max position= +180.002 deg		//min position= -180.000 deg
	}

	if (position>0)
		sign_pos = '+';
	else
		sign_pos = '-';

//
	whole_pos=fabsf(position);							//position's integer part
	thousandths_pos=(fabsf(position)-whole_pos)*1000;	//position's decimal part

	velocity=velocity*0.0001; //in order to see actual rad/s.

	if (velocity>0)
		sign_vel = '+';
	else
		sign_vel = '-';

	whole_vel=fabsf(velocity);							//velocity's integer part
	thousandths_vel=(fabsf(velocity)-whole_vel)*1000;	//velocity's decimal part

	if (whole_vel>100)									//saturation of the velocity
		whole_vel=0;

	//Implementation of the PD-Control
	Pout=(Kp*(desired_angle-position) + Kd*(desired_velocity-velocity));
	Pout_v=round(abs(Pout));

	if (Pout>0)
		dir=0;			//increasing direction
	else if (Pout<0)
		dir=1;			//decreasing direction
	else
		dir=1;			//no movement

	if (Pout_v>=saturation_limit)		//saturation of the Duty Cycle
		Pout_v=saturation_limit;

	duty=Pout_v*2+dir; 	//store direction bit
	duty=4*duty+2;		//2 left shifts and store of enable and reset.
	//1st bit->reset,2nd bit->enable,3rd bit->direction,4-11bits duty cycle

	if (dir==1)
		Pout_v=-Pout_v; //sign of duty cycle.

//	if (num_of_motor==5){
//			this is the function we use for printing
//		xil_printf("%d \t %d.%03d \t %c%d.%03d \t %c%d.%03d \t %d \t %d \t %d \t %c%d.%03d \t %d \t %d \t %d  \n\r",num_of_motor,whole_t,thousandths_t,sign_pos,whole_pos,thousandths_pos,sign_vel,whole_vel,thousandths_vel,Pout_v*100/(duty_resolution),int_kp,int_kd,sign_des,whole_des,thousandths_des,(int)(desired_velocity),saturation_limit*100/(duty_resolution),-saturation_limit*100/(duty_resolution));
//	}

	//Temporary save of the recorded data in the global variable array_print
	array_print[i][0]=num_of_motor;
	array_print[i][1]=whole_t;
	array_print[i][2]=thousandths_t;
	array_print[i][3]=sign_pos;
	array_print[i][4]=whole_pos;
	array_print[i][5]=thousandths_pos;

	array_print[i][6]=sign_vel;
	array_print[i][7]=whole_vel;
	array_print[i][8]=thousandths_vel;
	array_print[i][9]=Pout_v*100/(duty_resolution);
	array_print[i][10]=(int)(Kp);
	array_print[i][11]=(int)(Kd);
	array_print[i][12]=sign_des;
	array_print[i][13]=whole_des;
	array_print[i][14]=thousandths_des;
	array_print[i][15]=(int)(desired_velocity);
	array_print[i][16]=saturation_limit*100/(duty_resolution);
	array_print[i][17]=-saturation_limit*100/(duty_resolution);
	i++;
	return duty;
}

int position_controller(float t,float des_angle1,float des_angle2,int leg)
{
//    struct timeval end;
    int num_of_motor;
    float pos_temp,vel_temp;
    int mask;

    	//reading of position of first encoder
		pos_temp=(float)((encoder_resolution-1)&(*(baseaddr_p+6*(leg-1))));

		mask=(encoder_resolution)&(*(baseaddr_p+6*(leg-1))); //velocity's sign

		//reading of velocity of first encoder
		vel_temp=(float)*(baseaddr_p+1+6*(leg-1));


		if(mask==0)
			vel_temp = -vel_temp;

		num_of_motor=1+2*(leg-1);			//indicator of which motor we are referring to

		//send the PWM settings to the FPGA.
		Xil_Out32(((int)(baseaddr_p+2+6*(leg-1))),pd_control(t,num_of_motor,pos_temp,vel_temp,des_angle1));
		/////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////
		//Second Encoder Motor

		//reading of position of second encoder
		pos_temp=(float)((encoder_resolution-1)&(*(baseaddr_p+3+6*(leg-1))));

		mask=(encoder_resolution)&(*(baseaddr_p+3+6*(leg-1))); //velocity's sign

		//reading of velocity of second encoder
		vel_temp=(float)*(baseaddr_p+4+6*(leg-1));

		if(mask==0)
			vel_temp = -vel_temp;

		num_of_motor=2+2*(leg-1);			//indicator of which motor we are referring to

		//send the PWM settings to the FPGA.
		Xil_Out32(((int)(baseaddr_p+5+6*(leg-1))), pd_control(t,num_of_motor,pos_temp,vel_temp,des_angle2));

		return 0;
}

float lerp(float init_value, float init_time, float fin_value, float time_interval, float time_now){

	return (init_value*((init_time+time_interval)-time_now)+fin_value*(time_now-init_time))/(time_interval);
}

int store_data_in_sd(void)
{
	FRESULT Res;
	UINT NumBytesRead;
	UINT NumBytesWritten;
	u32 BuffCnt;
	u32 FileSize = (8*1024);
	TCHAR *Path = "0:/";
	int j;
	/*
	 * Register volume work area, initialize device
	 */
	Res = f_mount(&fatfs, Path, 0);

	if (Res != FR_OK) {
		return XST_FAILURE;
	}

	/*
	 * Open file with required permissions.
	 * Here - Creating new file with read/write permissions. .
	 * To open file with write permissions, file system should not
	 * be in Read Only mode.
	 */
	SD_File = (char *)FileName;

	Res = f_open(&fil, SD_File, FA_CREATE_ALWAYS | FA_WRITE | FA_READ);
	if (Res) {
		return XST_FAILURE;
	}

	/*
	 * Pointer to beginning of file .
	 */
	Res = f_lseek(&fil, 0);
	if (Res) {
		return XST_FAILURE;
	}

	/*
	 * Write data to file.
	 */
	j=i;
	xil_printf("The value of i is : %d\n\r",i);
    for (i=0;i<j;i++){
    	Res = f_printf(&fil,"%d \t %d.%03d \t %c%d.%03d \t %c%d.%03d \t %d \t %c%d.%03d \n\r",array_print[i][0],array_print[i][1],array_print[i][2],array_print[i][3],array_print[i][4],array_print[i][5],array_print[i][6],array_print[i][7],array_print[i][8],array_print[i][9],array_print[i][12],array_print[i][13],array_print[i][14]);
    	if (Res == -1) {
			return XST_FAILURE;
		}
    }
	/*
	 * Close file.
	 */
	Res = f_close(&fil);
	if (Res) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

int8_t inbyte_nb (void) {

u32 ReceivedByte;



       /* Check if there is data */

       if (!XUartPs_IsReceiveData(STDIN_BASEADDRESS)) {

              return -1;

       }



       /* Read a byte from the input buffer */

       ReceivedByte = XUartPs_ReadReg(STDIN_BASEADDRESS, XUARTPS_FIFO_OFFSET);



       /* Return the byte received */

       return (int8_t) ReceivedByte;

}
