--------------------------------------------------------------------------------
--
--   FileName:         pwm.vhd
--   Dependencies:     none
--   Design Software:  Quartus II 64-bit Version 12.1 Build 177 SJ Full Version
--
--   HDL CODE IS PROVIDED "AS IS."  DIGI-KEY EXPRESSLY DISCLAIMS ANY
--   WARRANTY OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING BUT NOT
--   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
--   PARTICULAR PURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL DIGI-KEY
--   BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR CONSEQUENTIAL
--   DAMAGES, LOST PROFITS OR LOST DATA, HARM TO YOUR EQUIPMENT, COST OF
--   PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
--   BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
--   ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS.
--
--   Version History
--   Version 1.0 8/1/2013 Scott Larson
--     Initial Public Release
--   Version 2.0 1/9/2015 Scott Larson
--     Transistion between duty cycles always starts at center of pulse to avoid
--     anomalies in pulse shapes
--    
--------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.all;
ENTITY pwm_freq IS
  GENERIC(          --The values defined below will only apply in case the "pwm_freq" entity is used as the top module
                    --Otherwise, if another project utilizes it as a component, then the generic variables will be defined there (See the corresponding "Generic Map")
      sys_clk         : INTEGER := 100_000_000;                             --system's clock frequency in Hz
      pwm_frequency   : INTEGER := 20_000;                                  --PWM switching frequency in Hz
      bits_resolution : INTEGER := 14;                                      --bits of resolution setting the duty cycle
      phases          : INTEGER := 1);                                      --number of output pwms and phases
  PORT(
      clk       : IN  STD_LOGIC;                                            --system clock
      reset     : IN  STD_LOGIC;                                            --asynchronous reset
      ena       : IN  STD_LOGIC;                                            --latches in new duty cycle
      duty      : IN  STD_LOGIC_VECTOR(bits_resolution-1 DOWNTO 0);         --duty cycle
      pwm_out   : OUT STD_LOGIC_VECTOR(phases-1 DOWNTO 0));                 --pwm outputs
END pwm_freq;

ARCHITECTURE logic OF pwm_freq IS
  CONSTANT  period     :  INTEGER := sys_clk/pwm_frequency;                 --number of clocks in one pwm period
  TYPE counters IS ARRAY (0 TO phases-1) OF INTEGER RANGE 0 TO period - 1;  --data type for array of period counters
  SIGNAL  count        :  counters := (OTHERS => 0);                        --array of period counters
  SIGNAL   half_duty_new  :  INTEGER RANGE 0 TO period/2 := 0;              --number of clocks in 1/2 duty cycle
  SIGNAL   duty_new  :  INTEGER RANGE 0 TO period := 0;  
  TYPE half_duties IS ARRAY (0 TO phases-1) OF INTEGER RANGE 0 TO period/2; --data type for array of half duty values
  SIGNAL  half_duty    :  half_duties := (OTHERS => 0);                     --array of half duty values (for each phase)
  TYPE duties IS ARRAY (0 TO phases-1) OF INTEGER RANGE 0 TO period;        --data type for array of half duty values
  SIGNAL  full_duty    :  duties := (OTHERS => 0);   
  signal pwm_n_out : std_logic_vector(phases-1 downto 0);                   --array of half duty values (for each phase)
BEGIN
  PROCESS(clk, reset)
  BEGIN
    IF(reset = '1') THEN                                                    --asynchronous reset
      count <= (OTHERS => 0);                                               --clear counter
      pwm_out <= (OTHERS => '0');                                           --clear pwm outputs
      pwm_n_out <= (OTHERS => '0');                                         --clear pwm inverse outputs
    ELSIF(clk'EVENT AND clk = '1') THEN                                     --rising system clock edge
      IF(ena = '1') THEN                                                    --latch in new duty cycle
        half_duty_new <= conv_integer(duty)*period/(2**bits_resolution)/2;  --determine clocks in 1/2 duty cycle
        duty_new <= conv_integer(duty)*period/(2**bits_resolution);
      END IF;
      FOR i IN 0 to phases-1 LOOP                                           --create a counter for each phase
        IF(count(0) = period - 1 - i*period/phases) THEN                    --end of period reached
          count(i) <= 0;                                                    --reset counter
          half_duty(i) <= half_duty_new;
          full_duty(i) <= duty_new;                                         --set most recent duty cycle value
        ELSE                                                                --end of period not reached
          count(i) <= count(i) + 1;                                         --increment counter
        END IF;
      END LOOP;
      FOR i IN 0 to phases-1 LOOP                                           --control outputs for each phase
        IF(count(i) <= full_duty(i)) THEN  
          pwm_out(i) <= '1';                                                --deassert the pwm output
          pwm_n_out(i) <= '0';                                              --assert the pwm inverse output
        ELSIF(count(i) > full_duty(i)) THEN   
          pwm_out(i) <= '0';                                                --assert the pwm output
          pwm_n_out(i) <= '1';                                              --deassert the pwm inverse output
        END IF;
      END LOOP;
    END IF;
  END PROCESS;

END logic;